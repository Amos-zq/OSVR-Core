/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 15.08.2 ] */

/* [wxMaxima: section start ]
Utility definitions
   [wxMaxima: section end   ] */

/* [wxMaxima: subsect start ]
quat to rotation matrix
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
This is the rotation matrix corresponding to a unit quaternion in wxyz format.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
quatToRotMatrix(q) := matrix(
    [1-2*(q[3]^2 + q[4]^2), 2*(q[2]*q[3] - q[1] * q[4]), 2*(q[2]*q[4] + q[1]*q[3])],
    [2*(q[2]*q[3]+q[1]*q[4]), 1 - 2*(q[2]^2 + q[4]^2), 2*(q[3]*q[4] - q[1]*q[2])],
    [2*(q[2]*q[4] - q[1]*q[3]), 2*(q[3]*q[4] + q[1]*q[2]), 1-2*(q[2]^2+q[3]^2)]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
Quaternion Exponentiation
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
Takes in just the vector part of a quaternion.
Note that divide an angular velocity dt (or incremental rotation) by 2 and you can feed it into this function to get a quaternion to compose.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
qPureExp(src) := block([theta, scale],
    theta : sqrt(src . transpose(src)),
    scale : sin(theta)/theta,
    [cos(theta), src[1]*scale, src[2]*scale, src[3]*scale]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
qSmallPureExp(src):= block([theta, scale],
    theta : sqrt(src . transpose(src)),
    scale : 1,
    [cos(theta), src[1]*scale, src[2]*scale, src[3]*scale]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
qPureExp([.1, .1, .1]/2);
qSmallPureExp([.1, .1, .1]/2);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
Small angle rotation
   [wxMaxima: subsect end   ] */

/* [wxMaxima: input   start ] */
smallAngleMatrix(w) := matrix([0, -w[3], w[2]], [w[3], 0, -w[1]], [-w[2], w[1], 0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Projecting without distortion
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
This is the "simple" version without distortion in it.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
projectPointRotMatrix(rot, translation, objPt, fx, fy, cx, cy) := 
block([xformed, xp, yp, x, y, z, u, v],
    xformed : rot . transpose(matrix(objPt)) + translation,
    xp : (xformed[1]/xformed[3])[1],
    yp : (xformed[2]/xformed[3])[1],
    u : fx * xp + cx,
    v : fy * yp + cy,
    [u,v]);
projectPoint(quat, translation, objPt, fx, fy, cx, cy) := projectPointRotMatrix(quatToRotMatrix(quat), translation, objPt, fx, fy, cx, cy);
projectPoint([1,0,0,0], [0,0,0], [1, 2, 3], 452.9, 452.9, 320, 240);
projectPointRotMatrix(quatToRotMatrix(qSmallPureExp([0,0,0])), [0,0,0], [1, 2, 3], 452.9, 452.9, 320, 240);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: subsect start ]
Corresponding jacobian
   [wxMaxima: subsect end   ] */

/* [wxMaxima: comment start ]
This version uses subscripts in the final result, making it more readable.


There needs to be 6 zero columns inserted after the first 6 columns.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
block([myquat, myincrot, mypos, mybeacon, q, incrot, pos, beacon, meas],
    myincrot: [incrot[0], incrot[1], incrot[2]],
    myquat: [qw, qx, qy, qz],
    mypos : [pos[0], pos[1], pos[2]],
    mybeacon : [beacon[0], beacon[1], beacon[2]],
    meas : projectPointRotMatrix(quatToRotMatrix(qSmallPureExp(myincrot)) . quatToRotMatrix(myquat), mypos, mybeacon, fl, fl, cx, cy),
jacobian(meas, [pos[0], pos[1], pos[2],incrot[0], incrot[1], incrot[2], beacon[0], beacon[1], beacon[2]]));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
block([myquat, myincrot, mypos, mybeacon, q, incrot, pos, beacon, meas],
    myincrot: [incrot[0], incrot[1], incrot[2]],
    myquat: [qw, qx, qy, qz],
    mypos : [pos[0], pos[1], pos[2]],
    mybeacon : [beacon[0], beacon[1], beacon[2]],
    meas : projectPointRotMatrix(quatToRotMatrix(qSmallPureExp(myincrot)) . quatToRotMatrix(myquat), mypos, mybeacon, fl, fl, cx, cy),
[jacobian(meas, mypos), jacobian(meas, myincrot), jacobian(meas, mybeacon)]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Distortion
   [wxMaxima: section end   ] */

/* [wxMaxima: fold    start ] */

/* [wxMaxima: comment start ]
Now for the version with distortion -
right now only handling up through k3, k4-k6 go on the bottom instead...
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
projectDistortedPoint(quat, translation, objPt, fx, fy, cx, cy, k, p) := 
block([xformed, xp, yp, r2, radDistort, xpp, ypp, x, y, z, u, v],
    xformed : quatToRotMatrix(quat) . objPt + translation,
    xp : (xformed[1]/xformed[3])[1],
    yp : (xformed[2]/xformed[3])[1],
    r2 : xp^2 + yp^2,
    radDistort : (1+k[1]*r2+k[2]*r2^2+k[3]*r2^3),
    xpp : xp * radDistort + 2*p[1]*xp*yp + p[2]*(r2 + 2*xp^2),
    ypp : yp * radDistort + p[1]*(r2+2*yp^2)+2*p[2]*xp*yp,
    u : fx * xpp + cx,
    v : fy * ypp + cy,
    [u,v]);
projectDistortedPoint([1,0,0,0], [0,0,0], [1, 2, 3], 452.9, 452.9, 320, 240, [1.252916e-06, -1.752020e-11, 6.405327e-17], [0, 0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: section start ]
Comparing
   [wxMaxima: section end   ] */

/* [wxMaxima: fold    start ] */

/* [wxMaxima: input   start ] */
distortionDifference(quat, translation, fx, fy, cx, cy, k, p) := 
buildq([quat, translation, fx, fy, cx, cy, k, p],
    projectDistortedPoint(quat, translation, point, fx, fy, cx, cy, k, p) - projectPoint(quat, translation, point, fx, fy, cx, cy));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
distortionDifference([1,0,0,0], [0,0,0], 452.9, 452.9, 320, 240, [1.252916e-06, -1.752020e-11, 6.405327e-17], [0, 0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
distortionDifference(quat, translation, fx, fy, cx, cy, k, p) := 
buildq([quat, translation, fx, fy, cx, cy, k, p],lambda([point], 
    projectDistortedPoint(quat, translation, point, fx, fy, cx, cy, k, p) - projectPoint(quat, translation, point, fx, fy, cx, cy)));
distortionDifference([1,0,0,0], [0,0,0], 452.9, 452.9, 320, 240, [1.252916e-06, -1.752020e-11, 6.405327e-17], [0, 0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
%([1,1,1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: section start ]
Outputting jacobian in a way we can compute
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
Will need some transformation, the seds committed into the repo,
and finally manual touch-ups (making sure some numbers are doubles, replacing ^, etc)
    
Didn't have time to write the Maxima or Lisp code to properly export directly
to C code, so the stepwise procedure will have to suffice.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
A few notes:
Some of these seem to be pretty common quantities, for instance, componentwise squared and cubed incrot was seen. So was a component-wise squaring of the quaternion.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
exportBlock(myblock, incrementalFn, matrixFn) := block([blockargs, len, incFile, matrixFile, i],
    blockargs: args(myblock),
    len: length(blockargs),
    incFile: openw(incrementalFn),
    for i:2 thru len - 1 do printf(incFile, "~a~%", blockargs[i]),
    close(incFile),
    matrixFile: openw(matrixFn),
    printf(matrixFile, "~a~%", blockargs[len]),
    close(matrixFile)
    )$
printBlock(myblock, func) := block([blockargs, len, i],
    blockargs: args(myblock),
    len: length(blockargs),
    for i:2 thru len do print(string(func(blockargs[i])))
    )$
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
replaceExponentsOnce(expr) := block([arg, power, newexpr, i],
    if atom(expr) then expr elseif operatorp(expr, "^") then (
        arg : args(expr)[1],
        power: args(expr)[2],
        newexpr : string(arg),
        for i: 2 thru power do ( newexpr : concat(string(arg), " * ", newexpr)),
        return(concat("(", newexpr, ")"))
    ) else (return(expr))
);
replaceExponents(expr) := scanmap(replaceExponentsOnce, expr);
replaceExponents(x^3);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
tempreplaceExponentsOnce(expr) := block([arg, power, newexpr, i],
    if atom(expr) then (print("got atom", expr), expr) elseif operatorp(expr, "^") then (
        arg : args(expr)[1],
        power: args(expr)[2],
        print("got exponentiation, arg", arg, "power", power),
        if power < 0 then return(1/tempreplaceExponentsOnce(1/expr)) else 
        return(cons(arg, join(makelist("*", power-1), makelist(arg, power-1))))
    ) else (print("Got something else, op ", op(expr), "args ", args(expr)), return(expr))
);
tempreplaceExponents(expr) := (print("Starting with expression ", expr),scanmap(tempreplaceExponentsOnce, expr));
tempreplaceExponents(1/%36^2);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
processSubscripts(a) := a;
processExpression(expr) := replaceExponents(processSubscripts(expr));
processLine(line) := block([lineargs],
    lineargs : args(line),
    if operatorp(line, ":") then (
        sconcat("auto ", string(lineargs[1]), " = ", processExpression(lineargs[2]), ";" )
    ) else (
        string(line)
    )
);
matrixCodegen(mat) := block([myblock, blockargs, len, i],
    myblock: ev(optimize(mat), optimprefix: v),
    blockargs: args(myblock),
    len: length(blockargs),
    for i:2 thru len do print(processLine(blockargs[i])),
    print(processLine(blockargs(len)))
);
matrixCodegen(H);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
matrixCodegen(H);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */

    for i:2 thru len do print(string(func(blockargs[i])))
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
printBlock(optimize(H), args);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
commonSubs : append(
    makelist(incrot[i]^2 = incrotSqr[i], i, 3),
    makelist(incrot[i]^3 = incrotCu[i], i, 3),
    [incrotSqr[1] + incrotSqr[2]+incrotSqr[3] = incrotSqrNorm, sqrt(incrotSqrNorm) = incrotNorm],
    makelist(q[i]^2 = qSqr[i], i, 4),
    makelist(q[i]^3 = qCu[i], i, 4));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
optimH:optimize(H);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
optimH:optimize(subst(commonSubs, H));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
optimH:optimize(replaceExponents(subst(commonSubs, H)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
exportBlock(optimH, "videotrackerjacobian.txt", "jacobianmatrix.txt");
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
